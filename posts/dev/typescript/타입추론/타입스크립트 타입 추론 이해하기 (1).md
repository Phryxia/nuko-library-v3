---
date: 2022-09-21 13:22
tags: ['typescript', '타입스크립트', '타입', 'ts', '추론']
---

# 개요

TypeScript는 모던 웹 개발에서 빼놓을 수 없는 중요한 개발 도구다. JavaScript의 유연성을 유지하면서도, 생산성을 떨어트리지 않기 위해 정적 분석이 가능토록 하였다.

TypeScript로 무언가를 개발하는 것은 그리 어렵지 않다. 왜냐면 TypeScript는 JavaScript을 포함하는 집합(Superset)이기에 러닝커브가 그리 가파르지 않기 때문이다. 하지만 조금만 복잡한 경우를 마주하면 바로 외계어처럼 느껴지는 것이 TypeScript이다.

```ts
type FirstType<T extends unknown[]> = T extends [infer F, ...unknown[]] ? F : never

type X = FirstType<[number, string, object]> // number!
```

특히 조건부 타입추론(`extends`)으로 넘어가면 이걸 어떻게 읽어야 할 지 난감할 정도로 어렵게 느껴진다. 이 정도로 복잡한 타이핑을 실무에서 쓰는 것이 의미가 있는지는 갑론을박이 있다. 하지만 그건 개인의 판단에 맡길 것이고, 여기서는 다루지 않는다.

이 시리즈에서는 TypeScript의 타입 추론을 수학적으로 이해해보고자 한다. 자연어와 예시를 통해서 타입 시스템을 이해하는 것은 한계가 있으며, 집합론으로 아주 간단한 몇 개의 규칙을 숙지하면 기존에 외계어 같던 타입 추론 시스템이 좀 더 쉽게 다가올 것이다.

## 들어가기에 앞서

TypeScript는 2022년 기준 제대로 된 언어 명세(Specification)가 없다. 과거에는 잠시 있었던 적이 있는데, 급속도로 팽창한 타입스크립트 생태계의 개발자들은 문서 갱신을 제때 하지 못했고, 결국 공식 스펙으로 간주하지 않고 [버려졌다(Archived)](https://github.com/microsoft/TypeScript/tree/main/doc).

때문에 무엇이 올바른 TypeScript의 구문이고, 타입 추론인지는 Microsoft 개발자들만 알 것이다. 심지어 그들조차도 소스 전체를 조사하지 않는 한, 모든 경우에 대한 동작은 모를 것이다. 실제로 가끔 일관성에서 벗어난 동작을 하는 경우가 있고, 글쓴이 또한 [이슈](https://github.com/microsoft/TypeScript/issues/50346)를 제보한 바가 있다.

따라서 이 시리즈에서 말하는 것들이 모두 TypeScript에서 100% 통용되는 것은 아니라는 것을 말한다. 이 시리즈에 삽입된 코드들은 글이 작성된 당시 버전의 [TypeScript Playground](https://www.typescriptlang.org/play)에서 검수를 거친 것임을 알린다.

# 구조적 타입 시스템(Structural Type System)

TypeScript는 **구조적 타입 시스템(Structural type System)**을 채택하고 있다. 구조적 타입 시스템이란, 데이터 타입을 **그것이 가진 속성으로 추론**하며, 타입의 이름이나 선언된 위치에 구애받지 않는 시스템이다.

이것에 반하는 시스템으로 **이름 기반 타입 시스템(Nominal Type System)**이 있다. 근대에 만들어진 언어들의 대부분이 여기에 속하는데, 타입을 선언할 때 **사용한 이름에 기반**하여 타입을 식별한다.

예컨데 아래의 Java 코드를 TypeScript와 비교해보자. A와 B는 구조는 같지만, 다른 타입으로 간주한다. 게다가 APrime은 A와 공통점이 있음에도, 상속을 하지 않았기 때문에 무관한 타입으로 간주한다.

```java
// java
class A {
	public String name;
	public int age;
}

class B {
	public String name;
	public int age;
}

class APrime {
	public String name;
	public int age;
	public APrime parent;
}
```

이것과 비슷한 것을 TypeScript로 만들면 아래와 같다.

```ts
// typescript
type A = {
	name: string
	age: number
}

type B = {
	name: string
	age: number
}

type APrime = {
	name: string
	age: number
	alias: string
}
```

여기서 `A`와 `B`는 이름은 다르지만 구조는 같다. 때문에 아래와 같은 일이 가능하다. `A`와 `B`는 구조적으로 완전히 동일하기 때문이며, `APrime`은 `A`의 모든 속성을 가지고 있기 때문에 대입이 가능하다. 하지만 Java에서는 이렇게 할 수 없다. 각 타입 간에 관계가 정의되지 않았기 때문이다.

```ts
function giveMeA(a: A) {
    // ... do something
}

const b: B = { name: 'foo', age: 0 }
giveMeA(b) // No Error

const ap: APrime = { name: 'foo', age: 0, alias: 'bar' }
giveMeA(ap) // No Error
```

여기서 알 수 있듯 구조적 타입 시스템에서 타입 이름은, 사람이 식별하기 쉬우라고 만든 별명에 가깝다. 타입 이름은 구조적으로 어떠한 의미도 가지지 않는다.

# 타입(Type)이란?

한 가지 근본적인 질문을 해보려고 한다. 프로그래밍 언어에서 타입이 뭘까? 나는 아래와 같이 정의하고 싶다.

> 타입(Type)이란, 메모리에 적재된 값에 의미를 부여하는 방식의 구분이다.

TypeScript가 됐든 C언어가 됐든, 모든 프로그래밍 언어에서 프로그래머가 입력한 코드와 그 부산물들은 메모리에 적재된다. 그런데 컴퓨터 메모리의 실체는 0과 1이 적절히 배열된 것일 뿐이다. 거기에 담긴 정보를 어떻게 해석하느냐에 따라서, 인간에게 갖는 의미가 달라진다. 

이진수 `01100001`은 숫자로 읽으면 *97*이고 ASCII 문자로 해석하면 `'A'`이며, 포인터로 해석하면 97번째 번지를 의미한다. 이때 '숫자', 'ASCII 문자', '포인터'는 넓은 의미에서 타입이라고 볼 수 있다.

이것에 대해 아주 진부하면서도 적절한 비유가 있는데, 김춘수 시인의 작품 '꽃'을 인용한다.

> 내가 그의 이름을 불러주었을 때,
> 그는 나에게로 와서
> 꽃이 되었다.
 
모든 변수/상수는 메모리 공간의 어떤 곳에 연결(bind)되어 있고, 언어가 지원하는 각종 연산(덧셈, 뺄셈, 참조 등)은 변수에 연결된 타입에 의해 정의 및 수행된다.
 
# 예고

다음 글에서는 집합론 관점에서 TypeScript의 타입 시스템을 다루고자 한다. 시간이 날 때마다 글을 추가할 예정이다.