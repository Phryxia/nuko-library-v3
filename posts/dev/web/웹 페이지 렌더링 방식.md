---
date: 2022-09-12 12:28
tags: ['web', 'csr', 'ssr', 'ssg', 'pre-rendering']
---

# 웹 페이지 렌더링 방식

사용자가 브라우저에 URL을 입력하고 엔터를 치면, 페이지에 대한 요청이 서버로 날아간다. 서버는 보여줄 웹페이지를 담은 HTML 파일을 응답한다. 이것들은 모두 HTTPS 프로토콜로 주고받는다.

이때 각각의 웹 페이지를 서버가 제공하는 방법으로 다음 3가지가 있다.

1. 서버 사이드 렌더링
2. 클라이언트 사이드 렌더링
3. 사전 렌더링

## 서버 사이드 렌더링

**서버 사이드 렌더링(Server Side Rendering, SSR)** 은 사용자의 요청에 따라 웹 페이지를 동적으로 구성하여 응답하는 방식이다. 초창기부터 쓰이던 방법이다.

고전적인 SSR 도구로 `php`, `jsp`, `asp` 가 있으며, 현대에는 [Next.js](https://nextjs.org/), [Remix](https://remix.run/) 같은 것도 찾아볼 수 있다.

### 장점

#### 쾌적한 UX

SSR 방식을 쓰면 유의미한 콘텐츠가 완성된 상태로 브라우저에 정보가 도착하므로, **사용자가 흰 화면을 보는 시간이 짧다**. 또한 클라이언트 입장에서는 무거운 스크립트를 실행할 필요가 없어서 성능적으로 가볍다.

#### 검색엔진최적화(SEO) 용이

SSR의 또다른 장점은 **SEO가 쉽다**는 점이다. 웹 크롤러가 js 스크립트를 실행하지 않아도, HTML 파일 안에 유의미한 정보가 존재하기 때문이다. 

검색엔진 크롤러는 HTML을 읽고 거기에 있는 텍스트 요소들을 분석하고, 다른 페이지로의 링크(`<a>` 태그의 `href` 속성을 본다)를 읽어 페이지 간의 연관성을 분석한다.

똑똑한 크롤러는 js 스크립트를 실행할 수도 있긴 하지만, 모든 경우에 해당되지 않는다. 대부분의 경우 검색 결과 개선에 도움되지 않는 정보가 더 많아, 굳이 서버 자원을 투입해가면서까지 js를 실행하지는 않는다.

콘텐츠 렌더링을 클라이언트에만 의존할 경우, 크롤링 봇 입장에서는 js를 실행해야만 볼 수 있는 콘텐츠가 없으므로, 검색엔진에 유의미한 정보를 추출하지 못하고 사이트를 떠나게 된다.

### 단점

#### 서버 자원을 많이 사용

SSR의 결정적인 단점은 **서버에 부하가 걸린다**는 것이다. 서버 내부에서 HTML을 렌더링하는 컨테이너가 떠야 하므로, 그냥 정적 파일을 서빙하는 것과는 비교할 수 없을 정도로 오버헤드가 크다. 호출하는 API의 양과 성격에 따라서, 오히려 UX를 저하할 정도로 응답속도가 느려질 수도 있다.

#### 융통성이 없음

순수한 SSR은 융통성이 없다. 예를 들어 로그인 한 유저의 ID를 보여주는 웹 페이지를 생각해보자. 사용자별로 달라지는 부분은 고작 ID를 띄우는 DOM 정도일텐데, 이 **작은 차이를 위해서 전체 페이지를 매 호출마다 렌더링**하는 것은 비효율적이다.

#### 상대적으로 높은 개발 난이도

SSR에서는 서버 환경에서 실행할 수 없는 코드(ex: 브라우저 API)와 클라이언트 환경에서 실행할 수 없는 코드(ex: 환경변수 참조)를 신경써야 한다. 프레임워크의 도움을 받지 않을 경우 개발 난이도는 상상을 초월할 정도로 올라가며, 프레임워크를 사용하더라도 여전히 신경써야 할 점이 많다. 

특히 코드 재사용을 용이하게 하려면, 트리쉐이킹과 코드 분할을 잘 해두어야 서버 코드가 클라이언트 번들에 딸려들어가지 않는다. 그만큼 SSR 방식을 사용할 경우 공부할 것이 많고 설정할 것도 많다.

## 클라이언트 사이드 렌더링

**클라이언트 사이드 렌더링(Client Side Rendering, CSR)** 은 일단 골격 웹페이지를 다운 받은 뒤, 실제 콘텐츠는 JavaScript를 실행하여 DOM을 만드는 방식이다. 이 과정에서 추가로 필요한 API를 AJAX로 호출할 수도 있다.

CSR은 Node.js를 필두로 JavaScript의 위상이 높아지면서, [Angular](https://angular.io/), [React](https://reactjs.org/), [Vue.js](https://vuejs.org/) 같은 도구가 탄생하며 나타난 방식이다. 이들은 순수 HTML만으로는 생산성이 떨어지는 복잡한 작업들을 JavaScript로 처리하였고, 그것을 최종적으로 실행해야만 HTML 요소가 생긴다.

### 장점

#### 페이지 간 이동 시 UX 향상

100% CSR만으로 개발할 경우, 논리적 페이지가 분리돼 있어도 물리적 페이지(HTML 파일의 수)는 하나다. 이 때문에 최초 스크립트 로딩시간만 견디면, 그 이후로는 웹 페이지를 탐색할 때 **끊김없는(seamless) 경험**을 할 수 있다.

#### 개발이 편리함

SSR에서는 서버 환경에서 실행할 수 없는 코드(ex: 브라우저 API)와 클라이언트 환경에서 실행할 수 없는 코드(ex: 환경변수 참조)를 신경써야 한다. 트리 쉐이킹이나 코드 분할 같은 것들을 제대로 해주지 않으면, 브라우저에서는 문제를 안일으키지만 서버에서 문제를 일으킬 수 있다.

CSR은 처음부터 클라이언트 실행만을 보장하므로 이런 부분에 대한 신경을 꺼도 된다.

### 단점

#### 검색엔진최적화가 어려움

CSR의 단점은 **SEO가 안된다**는 점이다. 이를 해결하고자 인간 사용자에게는 CSR 방식의 웹페이지를 제공하더라도, SSR 또는 사전 렌더링 방식을 겸하는 서비스들도 있다.

#### 클라이언트 자원을 많이 사용

CSR 의존도가 심하면 클라이언트의 성능의 영향이 심해진다. 모든 환경이 1MB를 넘어가는 자바스크립트를 쌩쌩 돌릴 수 있는 쾌적한 곳은 아니다. 세상에는 이걸 쓰라고 만들어놨나 싶은 환경(ex: 엑스박스 내장 브라우저)도 존재한다. 이런 열악한 환경에서 접속할 가능성이 있는 서비스들은 CSR 의존도를 낮춰야 한다.

#### 스크립트 파일 크기 증가

논리적 페이지가 많아지면 JavaScript 파일의 크기가 증가한다. 잠재적으로 접속할 수 있는 페이지들에 관한 스크립트를 전부 포함해야 하기 때문이다. 그러나 사용자들의 대부분은 아주 일부분의 페이지에만 접속한다. 이는 상당한 데이터 낭비이다.

## 사전 렌더링(Pre-Rendering, SSG)

**사전 렌더링 방식(Pre-Rendering, Static Site Generation, SSG)**은 제공할 가능성이 있는 페이지를 HTML로 렌더링 한 뒤, 결과만 정적으로 제공하는 방식이다. CSR을 완전히 배제하는 것은 아니지만, CSR처럼 모든 콘텐츠를 브라우저에 맡기지는 않는다.

SSG는 제공하고자 하는 페이지가 정적인 경우에 유용하게 쓸 수 있다. 정적 페이지(Static Page)란, **시간이 지나도 페이지의 내용물이 바뀔 일이 없는 페이지**를 말한다. 이 기술 블로그도 사전 렌더링 방식을 채택하고 있다.

사전 렌더링은 `react`나 `vue`로 작성한 프로젝트에 `react-snap` 같은 플러그인을 써서 실현할 수도 있으며, `ejs`, `pug` 같은 SSR 스크립트를 기반으로 실현할 수도 있다. 아예 SSG를 타겟팅한 프레임워크(Next.js, [Gatsby](https://www.gatsbyjs.com/) 등)도 존재한다.

### 장점

#### 서버 자원을 적게 사용

SSR과 다르게, 최초 렌더링만 해두면 파일 서빙만 하면 되므로 서버 부하 경감에 도움이 된다. 또한 사용자는 요청할 때마다 렌더링을 기다리지 않아도 되므로, 매우 짧은 응답시간을 경험할 수 있다.

#### SEO가 용이함

완성된 콘텐츠가 하나의 요청에 대해 도착하므로, SSR과 동일하게 SEO가 용이하다.

### 단점

#### 페이지의 수에 민감

페이지의 경우의 수가 무한할 경우에는 써먹을 수가 없다. 예를 들어 구글 같은 검색 사이트를 생각해보자. 존재할 수 있는 검색 결과 페이지의 가능성은 무한에 가깝다. 그런 경우의 수를 전부 고려해서 사전 렌더링을 한다는 것은 불가능하다.

무한한 경우가 아니더라도, 페이지 수가 많아지면 서비스를 변경/배포할 때마다 모든 페이지를 렌더링해야 하기 때문에 배포 시간이 오래 걸린다. 이를 해결하기 위해 [점진적 페이지 생성(Incremental Page Regeneration)](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration) 같은 변종을 제공하는 프레임워크도 있다.

# 주의사항

## 한 가지 방식만 사용할 필요는 없다

서비스 하나를 개발할 때 꼭 한 가지 방식만 고집하지는 않는다는 점이다. 일부 페이지는 SSR을, 나머지는 SSG를 채택할 수도 있고, CSR적인 요소를 부분적으로 사용하기도 한다.

예를 들어 디씨인사이드 같은 커뮤니티 사이트를 개발한다고 가정해보자. 게시글의 수가 무척 많으므로 SSG는 어렵고, SSR과 CSR을 적절히 섞어야 한다. 여기서 고민해봐야 하는 것은 댓글 컴포넌트다.

나라면 댓글 컴포넌트는 CSR로 처리를 할 것인데, 이유는 다음과 같다.

- 댓글은 변화무쌍하기 때문에 SSG로는 변화를 반영하기 어렵다
- 댓글은 SEO에 유의미한 정보를 주지 않는다
- 댓글을 읽지 않고 내용만 읽고 떠나는 사용자가 대부분이다

따라서 브라우저에 댓글 컴포넌트가 화면에 들어오는 시점에, API를 호출하여 결과물을 렌더링하는 것이 바람직하다고 생각한다.

## SPA 여부와는 별개이다

**단일 페이지 어플리케이션(Single Page Application, SPA)** 는 물리적인 페이지(=HTML)는 하나지만, 논리적인 페이지는 여러 개인 앱을 말한다. 이와 반대인 것을 이르기 위해 **다중 페이지 어플리케이션(Multi Page Application, MPA)** 라는 용어도 있다.

사실 이 구분이 무척 모호하기도 하다. 아주 러프하게 말하자면... 최소한 사용자가 URL A로 접속하여 동일한 서비스의 하이퍼링크 B를 클릭했을 때 **새로운 HTML을 다운받으면** MPA인 것이고, 현재 로드된 HTML 파일에서 벗어나지 않고 **AJAX와 JavaScript로 DOM만 바꾸면** SPA라고 볼 수 있다.

SPA 여부는 **렌더링 방식과 관계가 없다**. 서버에 **페이지 하나**를 요청을 했을 때, 내가 완성된 HTML 파일을 받느냐(SSR/SSG) 일부 또는 전체가 빈 HTML 파일(CSR)을 받느냐가 렌더링 방식과 관계가 있다
