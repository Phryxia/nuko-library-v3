---
date: 2022-04-16 12:40
tags: ['재귀식', 'log', 'lg', 'recurrence equation', '이산수학']

---

# 문제 정의

함수 $T: \Z \rightarrow \Z$를 다음과 같이 재귀적으로 정의할 때, Big-O-Notation으로 $T$를 기술하라.
$$
T(n)=
\begin{cases}
 0 & \text{ if } n\le1 \\
 1 + T\left(\left\lfloor \frac{n}{2} \right\rfloor\right) &  \text{ if } n>1 
\end{cases}
$$


# 쉬운 것부터 풀어보자

한 번에 풀기 까다로워보인다. 일단 안에 있는 $n/2$가 무척 거슬린다. 처음에 떠오르는 아이디어는 $n$을 짝수라고 가정하는 것이다. 
$$
T(2m)=1+T(m)
$$
그러나 곧 다음으로 나아가려면 $m$이 홀수일 때도 알아야 함을 알 수 있다. 구조가 복잡해서 풀 수가 없다.



## 1. 거듭제곱인 경우

그러니 맨 처음에는 $k \ge 0$에 대해 $n=2^{k+1}$라고 가정해보자. ($k+1$인 이유는 뒤의 논의와 결을 맞추기 위함으로, $n = 1$일 땐 따로 처리하기 때문이다)
$$
T(2^{k+1}) = 1+T(2^k)\\
=1+1+T(2^{k-1})\\
=1+1+1+T(2^{k-2})\\
...\\
=k+1+T(2^0)\\
=k+1
$$
이제 $k = \lg (n - 1)$ 을 대입하면 $T(n)=\lg n$이 된다.



## 2. 나눠서 거듭제곱이 되는 경우

이제 좀 골치가 아파진다.

지금 알고 있는 경우는 $k \ge 0, \space n=2^{k+1}$인 경우 뿐이므로, $\left\lfloor \frac{n}{2} \right\rfloor=2^{k+1}$이 되는 $n$이 어떤 것인지 알면 구조를 좀 더 편하게 이해할 수 있다. 거듭제곱이 아니면서 이를 만족하는 $n$은 단 하나다.
$$
n = 2^{k+2} + 1
$$
따라서 $n = 2^{k+2}+1$이라면 다음과 같다.
$$
T(n)=T(2^{k+2} + 1)=1+T(2^{k+1})=2+k=\lg (n - 1)
$$
참고로 이 범위에 해당하는 $n$의 최솟값은 3이다.



## 3. 나머지 경우

위의 두 경우를 제외한 나머지는 2로 나누었을 때 2번이나 3번으로만 이동한다. 만약 1번으로 이동한다면 그건 2번인 경우 뿐이니까.

그렇다면 3 → 3으로 이동하더라도 숫자는 항상 작아질 것이고, 비둘기집 원리에 의해서 언젠가는 3 → 2로 이동하는 곳으로 수렴한다. 따라서 후자가 어떻게 생겼는지 분석해보자.

2로 나눠서 $2^{k+2}+1$이 되는 경우는 다음 2가지가 있다.
$$
n=2^{k+3}+2 \\
n=2^{k+3}+3
$$
이 경우에 계산을 해보면 다음과 같다.
$$
T(2^{k+3}+2) = 1 + T(2^{k+2}+1)= 1 + k + 2 =lg(n-2) \\
T(2^{k+3}+3) = 1 + T(2^{k+2}+1)= 1 + k + 2 =lg(n-3)
$$
그럼 2로 나눠서 $2^{k+3}+2$와 $2^{k+3}+3$이 되는 경우는?
$$
T(2^{k+4}+4) = 1 + T(2^{k+3}+3) = 1 + k + 3 = lg(n-4)\\
T(2^{k+4}+5) = 1 + T(2^{k+3}+2) = 1 + k + 3 = lg(n-5)\\
T(2^{k+4}+6) = 1 + T(2^{k+3}+3) = 1 + k + 3 = lg(n-6)\\
T(2^{k+4}+7) = 1 + T(2^{k+3}+3) = 1 + k + 3 = lg(n-7)
$$
패턴이 보이지 않는가? 범위만 알아서 신경써준다면 결국 $k \ge 0$에 대하여 아래와 같이 생각할 수 있다.
$$
T(n)=T(2^{k+m} + r) = k + m =\lg(n - r) \quad(\text{단, }m\ge 2 ,\space 2^{m-2}\le r<2^{m-1})
$$
놀랍게도 이 식의 결과는 조건만 바꾸면 1번과 2번을 동일하게 표현할 수 있다.



## 종합

1번과 2번을 종합해서 위의 식을 다시 예쁘게 써보면 다음과 같다.
$$
n = 2^k+r,\space k \ge 0,\space 0 \le r < 2^k\text{에 대해 }T(n)=k=\lg (n - r)
$$
이것을 직관적으로 생각해보면, 대략 자신보다 크지 않은 2의 거듭제곱수의 승수와도 같다. 우린 너무나도 잘 알고 있는 가우스 함수로 다음과 같이 표현할 수 있다.
$$
T(n)=\left\lfloor \lg(n) \right\rfloor
$$


# 좀 더 엄밀한 증명?

내가 전문 수학자는 아니다보니 논리가 상당히 지저분하긴 한데, 이것의 엄밀한 증명은 전세계가 사랑하는 알고리즘 교과서 *Introduction to Algorithms*에 소개가 돼 있다.

정확히는 일반항을 구하는게 아니라 $T(n) = O(\lg n)$임을 보이는데, 그 과정에서 거듭제곱이 아닌 수에 대해서, $T(n)$이 거듭제곱인 경우의 사잇값임을 증명한다.



# 이 식이 쓰이는 곳

분할정복 알고리즘의 시간 복잡도 증명에 꼭 등장한다. 대표적인 예시로 이분탐색을 들 수 있다.

```pseudocode
function binarySearch(list, target, s = 0, e = len(list) - 1):
  if s > e:
    return -1
  let m := floor((s + e) / 2)
  if target = list[m]:
    return m
  if target > list[m]:
    return binarySearch(list, target, m + 1, e)
  return binarySearch(list, 0, m - 1)
```

이 알고리즘에서 탐색 구간의 길이(`e - s + 1`)가 $n$인 경우 자식 함수 호출 횟수를 $T(n)$으로 둘 때 다음 재귀식을 풀어야 한다.
$$
T(n) = \begin{cases}
0 & \text{if } n = 0 \\
1 + T(\left\lfloor \frac{n - 1}{2} \right\rfloor) & \text{otherwise}
\end{cases}
$$
디테일이 조금 다르긴 하지만 큰 틀에서 보면 똑같은 경우다. 일반항을 구하는 건 별도로 계산을 해봐야 하지만, $1 + T(\left\lfloor \frac{n - 1}{2} \right\rfloor) \le 1 + T(\left\lfloor \frac{n}{2}\right\rfloor)$임을 고려하면 시간 복잡도는 $O(\lg n)$이 된다.
