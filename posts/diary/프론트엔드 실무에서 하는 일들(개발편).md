---
date: 2021-10-21 18:00
tags: ['프론트엔드', 'fe', '실무', '개발자', '웹']
---

프론트엔드 실무에서 하는 일들(업무편)에 이어지는 글이다. 실제로 FE 개발자들은 어떤 작업을 주로 할까? 6개월차 신입인 내가 경험한 것들을 위주로 적어보았다.

# 마크업 작업

실무에서 마크업이란 HTML 구조 짜고 CSS 스타일 입히는 것을 지칭한다. 기획 및 디자인 팀에서 피그마/제플린을 통해 서비스 시안을 공지하면, 그걸 실제 브라우저에서 띄울 수 있는 페이지로 만드는 작업이다.

FE 하기 싫다는 사람들의 대부분은 이 작업 때문에 스트레스를 받는다. 단순히 HTML 혹은 템플릿만 짜면 되거나 리액트/앵귤러 같은 프레임워크 기반일 경우에는 그나마 수월하지만, 바닐라 자바스크립트(혹은 타입스크립트)만 써서 CSR 페이지를 짜는 정신나간 프로젝트일 경우 난이도가 급상승한다. 왜냐고?

```ts
const container = document.createElement('div')
container.className = 'button-container'

const button = document.createElement('button')
button.innerText = 'click me!'
button.className = 'general-button'

container.appendChild(button)
return container
```

이렇게 짜야 되거든. 참고로 위에서 생성되는 DOM을 HTML로 표현하면 다음과 같다.

```html
<div class="button-container">
  <button class="general-button">click me!</button>
</div>
```

FE 개발을 기피하게 만드는 또다른 요소가 바로 CSS인데, 역사적인 이유로 스펙이 너무나 지저분해진 것이 큰 원인이다. 익숙해지기 전까지는 온갖 예외사항이나 겪어봐야만 알게 되는 직관적이지 않은 규칙 때문에, 외않돼?를 시전하며 삽질을 해야한다. 게다가 브라우저별로 동작이 조금씩 다르다던가, 심지어 CSS 해석 버그라도 발견되는 순간엔 분노 게이지가 끝까지 치솟는다.

그런데 항상 어딜가든 변태는 있기 때문에, 이 CSS에 꽂혀서 온갖 괴상한 작품을 만들어내는 이들도 있다. 100% Pure CSS Trick으로 구글링을 해보면 충격적인 작품들을 볼 수 있다. 대부분은 실용적이지 못한 CSS의 한계를 시험하는 수준에 그치지만, 가끔 실전에서 써먹을만한 유용한 것들도 있다.

마크업 개발자가 따로 있는 회사에서는 FE 개발자가 마크업을 건드리는 일이 잘 없다. 간단한 경우 FE 개발자가 CSS 수정을 할 때도 있으나, 수정이 조금만 복잡해지면 오히려 마크업 개발자들의 작업 플로우를 망치기 때문에 그 분들에게 맡기는 것이 좋다.

마크업 작업은 접근성과도 밀접한 연관이 있다. 겉보기엔 같더라도, 내부적으로 어떤 태그를 쓰느냐에 따라서 여러가지 편의기능의 동작이 달라진다. 스크린 리더를 고려한다던가, 아무리 저성능 쓰레기 레거시 IE 브라우저일 지라도 제대로 동작해야만 하는 특수한 상황일 경우 마크업 작업을 굉장히 신중하게 해야 한다.

# 로직 구현

# API 연동

정적 사이트라서 페이지 받아오는 거 빼고 서버랑 통신할 일이 없다면 편하겠지만, 대부분의 서비스는 동적이기 떄문에 통신이 필수적이다.

실무에서 은근히 시간을 많이 잡아먹는데, 보통 API는 백엔드(BE) 개발자가 작업을 하기 때문에 자신이 풀스택으로 개발하고 있는게 아니면 하염없이 기다려야 하기 때문이다. API에 문제가 생기면 FE 개발자가 혼자서 해결하는 것은 거의 불가능하다. 설사 본인이 BE를 할 줄 안다 하더라도, 엔터프라이즈 급 서비스의 서버 쪽 작업 맥락을 모르면 함부로 못 건드린다.

이 작업을 하기 위해 현대 FE 개발자가 알아야 하는 개념/도구는 다음과 같은 것들이 있다.

- API
- HTTP
- CORS
- REST
- AJAX: XMLHttpRequest, fetch API
- JSON, XML
- GraphQL
- 웹소켓
- Promise, async, await
- axios - 매우 널리 쓰이는 HTTP/웹소켓 통신 라이브러리
- BFF

# 라우팅 작업

FE 개발자들을 고통받게 만드는 또다른 작업이 바로 라우팅이다. 라우팅이란 각종 하이퍼링크를 클릭했을 때 특정 페이지로 이동할 수 있도록 해주는 작업을 말한다.

서버 사이드 렌더링(SSR)이 대세였던 웹 초창기에는 FE 개발자가 라우팅을 고려할 필요가 없었다. 서버에 들어온 요청에 맞는 페이지를 내보내면 끝이었기 때문이다. 그러나 클라이언트 사이드 렌더링(CSR)이 등장하면서 이야기가 복잡해졌다.

CSR은 기술적으로는 '단일 HTML' 페이지에서 **마치 여러 페이지가 있는 것처럼** DOM 조작을 하여 눈속임을 한다고도 볼 수 있다. 그러나 근본적으로 그것들은 다 '하나의 페이지' 안에서 일어나는 일이기 때문에, 별도의 조치를 하지 않으면 브라우저 주소창은 바뀌지 않고 초기 URL 그대로 남아있게 된다.

이게 문제가 되는 이유는 다음과 같다.

- 브라우저에서 새로고침을 하면 초기 페이지로 돌아가버린다.
- 브라우저에서 뒤로가기를 누르면 그 사이트에 들어오기 전으로 튕겨버린다. 개념적인 페이지는 구분이 돼 있더라도, 실제 물리적인 페이지는 하나기 때문이다.
- 그 페이지를 띄운 상태로 랜딩을 할 수가 없다. 주소창을 복사해서 다른 사람한테 공유해주더라도, 그가 의도한 페이지로 들어오지 못한다.

현재 페이지의 상태를 URL에 반영하고, 반대로 URL이 변경되었을 때 상태를 동기화하는 작업이 FE 라우팅의 본질이다. 라우팅에 관련된 것들로 다음과 같은 것이 있다.

- History API
- URL, URL Fragment, URL Query String
- express.js: node.js 서버에서 라우팅을 편하게 해주는 라이브러리

## 라우팅의 두 가지 방식

CSR에서 라우팅은 크게 해시기반 라우팅과 URL기반 라우팅으로 나뉜다. 

전자는 URL Fragment(흔히 해시라고 부르는)를 이용하며, 페이지 주소는 대충 `https://www.my-service.net/#some/page` 식으로 해시(#)를 붙여서 관리한다. 이 방식의 라우팅은 오로지 클라이언트가 전담한다. 서버에는 URL Fragment가 날아가지 않기 때문에 도메인 루트 주소로 요청이 이루어진다. (아까 예시의 경우 `https://www.my-service.net/index.html`을 찾는다)

- 서버 쪽 수정이 필요없다.
- SSR 적용이 불가능하다.
- 다른 용도로 해시를 쓸 수가 없다.

후자는 일반적인 URL 경로를 그대로 사용하는 방식이다. (ex: `https://www.my-service.net/some/page`) 이 방식을 사용할 경우 클라이언트 뿐만 아니라 서버에서도 조치가 필요하다. 예컨데 `index.html`에 모든 스크립트가 담겨올 때, 브라우저에서 해당 도메인의 어떤 주소로 호출하든 그 파일을 연결해야 하기 때문이다. (이게 이해가 되지 않는다면, 직접 간단한 서버를 짜서 실험해보면 된다. 로드 후에 링크를 눌러서 페이지를 바꾸는 건 할 수 있으나, 그 상태에서 새로고침하면 초기화면으로 돌아가거나 서버 구현에 따라 404 페이지가 뜰 것이다) 한술 더떠서 SSR을 병행하는 경우, 요청한 세부 URL 경로별로 다른 페이지를 렌더링해줘야 한다.

- 서버 쪽 협조가 필요하다.
- SSR 적용이 가능하다.
- 해시 사용에 영향이 없다.

라우팅을 직접 구현해서 처리하는 것은 매우 귀찮고 번거롭기 때문에, 관련 라이브러리를 사용한다. 각 프레임워크 별 특화된 라우팅 라이브러리가 있으며, 프레임워크에 내장된 경우도 있다.

- react-router
- next.js: 리액트 기반의 프레임워크. SSR와 CSR을 하나의 코드로 동시에 처리할 수 있게 해준다. 라우팅 관련 툴도 제공.

## 히스토리 문제

라이브러리를 쓰더라도 여전히 고된 작업이 남아있는데, 히스토리 조작 작업이다. 페이지 단위로만 URL을 다룰 경우 위의 도구들을 가져다 쓰거나 직접 라우터를 만들어 쓰면 달리 할 게 없다. 그러나 실제 서비스들은 페이지보다 더 작은 단위까지 요구한다. 예를 들어 게시글 조회 페이지에서 조회 기간을 3월에서 6월로 지정하는 기능이 있는 경우, URL Query(?로 시작하는 것)에 `?from=3;to=6` 등으로 정보를 기재한다. 이 쿼리가 붙은 URL은 그렇지 않은 것과 별개로 취급되기 때문에, 브라우저 히스토리에 별개의 히스토리로 남게 된다.

대부분의 경우엔 이게 문제가 되지 않지만, 이런 상황을 생각해보자. 어떤 페이지에 '돌아가기' 버튼이 있어서, 그걸 누르면 그곳에 접근하기 직전의 페이지로 돌아가야 한다. 참고로 그 페이지로 올 수 있는 경로는 매우 다양하다. 그냥 뒤로가기(`history.back()`)를 하면 되지 않느냐라고 생각할 수 있다. 그런데 만약 그 페이지에 앞서 말한 게시글 조회 필터 기능이 있고, 그걸 쿼리를 통해 동기화한다면? 

```
1 https://www.my-service.net/                  // 메인
2 https://www.my-service.net/posts             // 게시글 조회
3 https://www.my-service.net/posts?from=3;to=6 // 필터 설정
```

이렇게 히스토리가 쌓일텐데, 그렇다면 상황 3에서 돌아가기 버튼을 눌렀을 때 상황 2가 되는 것이 올바른 동작이라고 할 수 있을까? 이건 기획에 따라 다르지만, 보통은 상황 1이 되는 것이 자연스럽다. 그러나 브라우저에서 제공하는 History API로는 이것이 불가능하다. 보안상의 이유로 히스토리 내부를 까서 볼 수가 없고, 오로지 뒤로가기/앞으로가기/push/replace만 가능하기 때문이다.

이를 해결하려면 상황 2에서 상황 1의 주소를 어떻게든 알아내서 저장하고 있다가, 상황 3에서 돌아가기 버튼을 누를 때 그 주소로 `push` 해야 한다. 참고로 이렇게 하더라도 진정한 의미로 '돌아간' 것은 아니다. 오히려 1번 상황의 주소를 새로 '들어간 것'으로 취급된다.

```
1 https://www.my-service.net/                  // 메인
2 https://www.my-service.net/posts             // 게시글 조회
3 https://www.my-service.net/posts?from=3;to=6 // 필터 설정
4 https://www.my-service.net/                  // 필터 설정 후 돌아가기 누름
```

문제는 직전 페이지를 알아내기가 어렵다는 것이다. 그냥은 안되고, `sessionStorage`를 동원하여 매번 URL이 변경될 때마다 URL을 저장하는 '커스텀 히스토리' 관리를 해야한다. 한 번 만들어두면 편하긴 하겠지만, 그걸 구현하는게 되게 귀찮다. (내가 지금 회사에서 담당하는 서비스에 이런 이슈가 있어서, 조만간 관련 작업을 할 것으로 생각 중)